import{_ as n}from"./chunks/ErrorList.DUJwPVuR.js";import{B as t,o as r,c as o,ae as p,G as s,w as i}from"./chunks/framework.CCmhkGTA.js";import"./chunks/index.BI579x9g.js";import"./chunks/index.Ctuo7IKN.js";import"./chunks/index.eQmIA9o-.js";import"./chunks/index.CeVZZ3NP.js";const g=JSON.parse('{"title":"Errors","description":"","frontmatter":{},"headers":[],"relativePath":"doc/en/errors.md","filePath":"doc/en/errors.md"}'),l={name:"doc/en/errors.md"},T=Object.assign(l,{setup(c){return(u,e)=>{const a=t("ClientOnly");return r(),o("div",null,[e[0]||(e[0]=p(`<h1 id="errors" tabindex="-1">Errors <a class="header-anchor" href="#errors" aria-label="Permalink to &quot;Errors&quot;">â€‹</a></h1><p>There is a detailed guide on how to handle the ScreenshotOne API errors.</p><p>The request might return an error due to an internal error, invalid options or when the limit is reached. Our screenshot API follows the HTTP status code semantic and returns JSON in case of an error:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Content-Type: application/json</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    &quot;is_successful&quot;: false,</span></span>
<span class="line"><span>    &quot;error_code&quot;: &quot;an_error_code&quot;,</span></span>
<span class="line"><span>    &quot;error_message&quot;: &quot;An error message&quot;,</span></span>
<span class="line"><span>    &quot;documentation_url&quot;: &quot;...&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,4)),s(a,null,{default:i(()=>[s(n)]),_:1})])}}});export{g as __pageData,T as default};
